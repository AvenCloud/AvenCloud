import fetchHTTP from "node-fetch";
import os from "os";
import * as JSTT from "json-schema-to-typescript";
import { mkdirp, writeFile, readFile } from "fs-extra";
import openBrowser from "react-dev-utils/openBrowser";
import open from "open";
import minimist from "minimist";

class AvenError extends Error {
  name: string;
  message: string;
  data?: any;
  constructor(detail: { message: string; name: string; data?: any }) {
    super(detail?.message || "Unknown Error");
    this.message = detail.message;
    this.name = detail.name;
    this.data = detail.data;
  }
}

async function api(remoteHost: string, remoteSSL: boolean, endpoint: string, payload: any) {
  return fetchHTTP(`http${remoteSSL ? "s" : ""}://${remoteHost}/api/${endpoint}`, {
    method: "post",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(payload),
  }).then(async (res) => {
    const body = await res.json();
    if (res.status !== 200) {
      console.error("wayoy", res.status, body);
      throw new AvenError(body.error);
    }
    return body;
  });
}

type AuthenticatedShellConfig = {
  remoteHost: string;
  remoteSSL: boolean;
  username: string;
  authToken: string;
};

type ShellConfig =
  | {
      remoteHost: string;
      remoteSSL: boolean;
    }
  | AuthenticatedShellConfig;

const DEFAULT_SHELL_CONFIG: ShellConfig = {
  remoteHost: "aven.io",
  remoteSSL: true,
};

const SHELL_CONFIG_PATH = `${os.homedir()}/.config/aven`;

async function getShellConfigPath(): Promise<string> {
  await mkdirp(SHELL_CONFIG_PATH);
  return SHELL_CONFIG_PATH;
}

async function getShellConfig(): Promise<ShellConfig> {
  const shellPath = await getShellConfigPath();
  const configFilePath = `${shellPath}/AvenShellConfig.json`;
  try {
    const configData = await readFile(configFilePath, { encoding: "utf8" });
    const config = JSON.parse(configData);
    return config;
  } catch (e) {
    return DEFAULT_SHELL_CONFIG;
  }
}

async function doLogin({
  remoteHost,
  remoteSSL,
}: {
  remoteHost: string;
  remoteSSL: boolean;
}): Promise<AuthenticatedShellConfig> {
  const { token } = await api(remoteHost, remoteSSL, "device-login", {});
  const openURL = `http${remoteSSL ? "s" : ""}://${remoteHost}/login/device?t=${token}`;
  console.log(`To Log in, continue at: ${openURL}`);
  if (!openBrowser(openURL)) {
    open(openURL);
  }

  const { username } = await new Promise((resolve, reject) => {
    let queryTimeout = null;
    queryTimeout = setTimeout(() => {
      api(remoteHost, remoteSSL, "device-login-verify", { token })
        .then((resp) => {
          console.log("VERIFIED", resp);
        })
        .catch((e) => {
          console.error("ee", e);
        });
    }, 8_000);
  });

  // await fetch(`http${remoteSSL ? "s" : ""}://${remoteHost}/api/device-login`, {

  // })
  return {
    remoteHost,
    remoteSSL,
    username,
    authToken: token,
  };
}

async function getAuthenticateShellConfig(): Promise<AuthenticatedShellConfig> {
  const config = (await getShellConfig()) as AuthenticatedShellConfig;
  if (!config.username || !config.authToken) {
    return await doLogin(config);
  }
  return config;
}

export async function pull(siteName: string): Promise<any> {
  const { remoteHost, remoteSSL } = await getShellConfig();
  const { nodes, schema } = await api(remoteHost, remoteSSL, "site-schema-get", { siteName });
  // schema.isPublic tells us if an API key is needed..
  const allRecords: any = {};
  for (const nodeKey in nodes) {
    const node = nodes[nodeKey];
    if (node?.type === "record") {
      allRecords[nodeKey] = node;
    } else {
      console.error({ e: 111, nodeKey, node, time: Date.now() });
      throw new Error(`Cannot handle schema type of "${nodeKey}" `);
    }
  }
  const moduleExports = [];
  const definedTypes: any = {};
  for (const recordKey in allRecords) {
    const record = allRecords[recordKey];
    const typeDef = await JSTT.compile(record.record, recordKey, {
      bannerComment: "",
    });
    const typeKeyMatch = typeDef.match(/^export type (.*) =/);
    const typeKey = typeKeyMatch && typeKeyMatch[1];
    if (!typeKey) {
      console.error({ e: 112, typeDef, record, recordKey });
      throw new Error("Failed ts compilation");
    }
    definedTypes[recordKey] = typeKey;

    moduleExports.push(typeDef);
  }
  moduleExports.push(`
export type SiteSchema = {
${Object.entries(definedTypes)
  .map(([recordKey, typeKey]) => `  "${recordKey}": ${typeKey};`)
  .join("\n")}
}`);
  moduleExports.push(`
const Cloud = createClient<SiteSchema>({
  siteName: "${siteName}",
});
export default Cloud;
`);
  moduleExports.push(`
export type CloudLoad = SiteLoad<SiteSchema>;
`);
  const genFile = `
/* tslint:disable */

/**
 * This file was automatically generated by Aven CLI.
 * DO NOT MODIFY IT BY HAND. Instead, modify the Aven Cloud schema and re-run 'aven pull'
 */

import { createClient, SiteLoad } from "@aven/client";

${moduleExports.join("\n")}
`;
  const genFileLocation = `Cloud-${siteName}-Generated.ts`;
  await writeFile(genFileLocation, genFile);
  return { genFile, genFileLocation, definedTypes };
}

export function handleCli(argv: string[]): void {
  const args: CLIArgs = minimist(argv.slice(2));
  if (args.h === true) {
    console.log(`
Aven CLI tool

Usage:
aven pull SITE_NAME

        `);
  }

  const action = args._[0];
  if (action === "pull") {
    pull(args._[1])
      .then(({ definedTypes, genFileLocation, exportedInterfaces, genFile }) => {
        console.log(`Pulled ${Object.entries(definedTypes).length} properties to ${genFileLocation}`);
      })
      .catch((e) => {
        console.error("eerrorr", e);
      });
    return;
  } else if (action === "login") {
    console.log("Logging in");
    getAuthenticateShellConfig()
      .then(({ username }) => {
        console.log(`Logged in as ${username}`);
      })
      .catch((e) => {
        console.error("eerrorr", e);
      });
    return;
  }
  console.log("Command not found. Try -h");
  return;
}

if (require.main === module) {
  handleCli(process.argv);
}

type CLIArgs = {
  _: string[];
  h?: boolean;
};
