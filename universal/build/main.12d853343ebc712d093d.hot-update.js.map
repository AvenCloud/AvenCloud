{"version":3,"file":"main.12d853343ebc712d093d.hot-update.js","sources":["webpack:///src/react-navigation-native-container/createAppContainer.js"],"sourcesContent":["import React from 'react';\nimport { Linking, AsyncStorage } from 'react-native';\nimport { polyfill } from 'react-lifecycles-compat';\n\nimport {\n  PlatformHelpers,\n  NavigationActions,\n  invariant,\n} from '../react-navigation-core';\nimport docsUrl from './docsUrl';\n\nfunction isStateful(props) {\n  return !props.navigation;\n}\n\nfunction validateProps(props) {\n  if (isStateful(props)) {\n    return;\n  }\n\n  const { navigation, screenProps, ...containerProps } = props;\n\n  const keys = Object.keys(containerProps);\n\n  if (keys.length !== 0) {\n    throw new Error(\n      'This navigator has both navigation and container props, so it is ' +\n        `unclear if it should own its own state. Remove props: \"${keys.join(\n          ', '\n        )}\" ` +\n        'if the navigator should get its state from the navigation prop. If the ' +\n        'navigator should maintain its own state, do not pass a navigation prop.'\n    );\n  }\n}\n\n// Track the number of stateful container instances. Warn if >0 and not using the\n// detached prop to explicitly acknowledge the behavior. We should deprecated implicit\n// stateful navigation containers in a future release and require a provider style pattern\n// instead in order to eliminate confusion entirely.\nlet _statefulContainerCount = 0;\nexport function _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n}\n\n// We keep a global flag to catch errors during the state persistence hydrating scenario.\n// The innermost navigator who catches the error will dispatch a new init action.\nlet _reactNavigationIsHydratingState = false;\n// Unfortunate to use global state here, but it seems necessesary for the time\n// being. There seems to be some problems with cascading componentDidCatch\n// handlers. Ideally the inner non-stateful navigator catches the error and\n// re-throws it, to be caught by the top-level stateful navigator.\n\n/**\n * Create an HOC that injects the navigation and manages the navigation state\n * in case it's not passed from above.\n * This allows to use e.g. the StackNavigator and TabNavigator as root-level\n * components.\n */\nexport default function createNavigationContainer(Component) {\n  class NavigationContainer extends React.Component {\n    subs = null;\n\n    static router = Component.router;\n    static navigationOptions = null;\n\n    static getDerivedStateFromProps(nextProps, prevState) {\n      validateProps(nextProps);\n      return null;\n    }\n\n    _actionEventSubscribers = new Set();\n\n    constructor(props) {\n      super(props);\n\n      validateProps(props);\n\n      this._initialAction = NavigationActions.init();\n\n      if (this._isStateful()) {\n        this.subs = PlatformHelpers.BackHandler.addEventListener(\n          'hardwareBackPress',\n          () => {\n            if (!this._isMounted) {\n              this.subs && this.subs.remove();\n            } else {\n              // dispatch returns true if the action results in a state change,\n              // and false otherwise. This maps well to what BackHandler expects\n              // from a callback -- true if handled, false if not handled\n              return this.dispatch(NavigationActions.back());\n            }\n          }\n        );\n      }\n\n      this.state = {\n        nav:\n          this._isStateful() && !props.persistenceKey\n            ? Component.router.getStateForAction(this._initialAction)\n            : null,\n      };\n    }\n\n    _renderLoading() {\n      return this.props.renderLoadingExperimental\n        ? this.props.renderLoadingExperimental()\n        : null;\n    }\n\n    _isStateful() {\n      return isStateful(this.props);\n    }\n\n    _validateProps(props) {\n      if (this._isStateful()) {\n        return;\n      }\n\n      const { navigation, screenProps, ...containerProps } = props;\n\n      const keys = Object.keys(containerProps);\n\n      if (keys.length !== 0) {\n        throw new Error(\n          'This navigator has both navigation and container props, so it is ' +\n            `unclear if it should own its own state. Remove props: \"${keys.join(\n              ', '\n            )}\" ` +\n            'if the navigator should get its state from the navigation prop. If the ' +\n            'navigator should maintain its own state, do not pass a navigation prop.'\n        );\n      }\n    }\n\n    _urlToPathAndParams(url) {\n      const params = {};\n      const delimiter = this.props.uriPrefix || '://';\n      let path = url.split(delimiter)[1];\n      if (typeof path === 'undefined') {\n        path = url;\n      } else if (path === '') {\n        path = '/';\n      }\n      return {\n        path,\n        params,\n      };\n    }\n\n    _handleOpenURL = ({ url }) => {\n      const parsedUrl = this._urlToPathAndParams(url);\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const action = Component.router.getActionForPathAndParams(path, params);\n        if (action) {\n          this.dispatch(action);\n        }\n      }\n    };\n\n    _onNavigationStateChange(prevNav, nav, action) {\n      if (\n        typeof this.props.onNavigationStateChange === 'undefined' &&\n        this._isStateful()\n      ) {\n        /* eslint-disable no-console */\n        if (console.group) {\n          console.group('Navigation Dispatch: ');\n          console.log('Action: ', action);\n          console.log('New State: ', nav);\n          console.log('Last State: ', prevNav);\n          console.groupEnd();\n        } else {\n          console.log('Navigation Dispatch: ', {\n            action,\n            newState: nav,\n            lastState: prevNav,\n          });\n        }\n        /* eslint-enable no-console */\n        return;\n      }\n\n      if (typeof this.props.onNavigationStateChange === 'function') {\n        this.props.onNavigationStateChange(prevNav, nav, action);\n      }\n    }\n\n    componentDidUpdate() {\n      // Clear cached _nav every tick\n      if (this._nav === this.state.nav) {\n        this._nav = null;\n      }\n    }\n\n    async componentDidMount() {\n      this._isMounted = true;\n      if (!this._isStateful()) {\n        return;\n      }\n\n      if (process.env.NODE_ENV === 'development' && !this.props.detached) {\n        if (_statefulContainerCount > 0) {\n          console.error(\n            `You should only render one navigator explicitly in your app, and other navigators should by rendered by including them in that navigator. Full details at: ${docsUrl(\n              'common-mistakes.html#explicitly-rendering-more-than-one-navigator'\n            )}`\n          );\n        }\n      }\n      _statefulContainerCount++;\n      Linking.addEventListener('url', this._handleOpenURL);\n\n      const { persistenceKey } = this.props;\n      const startupStateJSON =\n        persistenceKey && (await AsyncStorage.getItem(persistenceKey));\n      let startupState = this.state.nav;\n      if (startupStateJSON) {\n        try {\n          startupState = JSON.parse(startupStateJSON);\n          _reactNavigationIsHydratingState = true;\n        } catch (e) {}\n      }\n\n      let action = this._initialAction;\n      if (!startupState) {\n        !!process.env.REACT_NAV_LOGGING &&\n          console.log('Init new Navigation State');\n        startupState = Component.router.getStateForAction(action);\n      }\n\n      const url = await Linking.getInitialURL();\n      const parsedUrl = url && this._urlToPathAndParams(url);\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const urlAction = Component.router.getActionForPathAndParams(\n          path,\n          params\n        );\n        if (urlAction) {\n          !!process.env.REACT_NAV_LOGGING &&\n            console.log('Applying Navigation Action for Initial URL:', url);\n          action = urlAction;\n          startupState = Component.router.getStateForAction(\n            urlAction,\n            startupState\n          );\n        }\n      }\n      if (startupState === this.state.nav) {\n        return;\n      }\n      this.setState({ nav: startupState }, () => {\n        _reactNavigationIsHydratingState = false;\n        this._actionEventSubscribers.forEach(subscriber =>\n          subscriber({\n            type: 'action',\n            action,\n            state: this.state.nav,\n            lastState: null,\n          })\n        );\n      });\n    }\n\n    componentDidCatch(e, errorInfo) {\n      if (_reactNavigationIsHydratingState) {\n        _reactNavigationIsHydratingState = false;\n        console.warn(\n          'Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state..'\n        );\n        this.dispatch(NavigationActions.init());\n      }\n    }\n\n    _persistNavigationState = async nav => {\n      const { persistenceKey } = this.props;\n      if (!persistenceKey) {\n        return;\n      }\n      await AsyncStorage.setItem(persistenceKey, JSON.stringify(nav));\n    };\n\n    componentWillUnmount() {\n      this._isMounted = false;\n      Linking.removeEventListener('url', this._handleOpenURL);\n      this.subs && this.subs.remove();\n\n      if (this._isStateful()) {\n        _statefulContainerCount--;\n      }\n    }\n\n    // Per-tick temporary storage for state.nav\n\n    dispatch = action => {\n      if (this.props.navigation) {\n        return this.props.navigation.dispatch(action);\n      }\n      this._nav = this._nav || this.state.nav;\n      const oldNav = this._nav;\n      invariant(oldNav, 'should be set in constructor if stateful');\n      const nav = Component.router.getStateForAction(action, oldNav);\n      const dispatchActionEvents = () => {\n        this._actionEventSubscribers.forEach(subscriber =>\n          subscriber({\n            type: 'action',\n            action,\n            state: nav,\n            lastState: oldNav,\n          })\n        );\n      };\n      if (nav && nav !== oldNav) {\n        // Cache updates to state.nav during the tick to ensure that subsequent calls will not discard this change\n        this._nav = nav;\n        this.setState({ nav }, () => {\n          this._onNavigationStateChange(oldNav, nav, action);\n          dispatchActionEvents();\n          this._persistNavigationState(nav);\n        });\n        return true;\n      } else {\n        dispatchActionEvents();\n      }\n      return false;\n    };\n\n    render() {\n      let navigation = this.props.navigation;\n      if (this._isStateful()) {\n        const nav = this.state.nav;\n        if (!nav) {\n          return this._renderLoading();\n        }\n        if (!this._navigation || this._navigation.state !== nav) {\n          this._navigation = {\n            dispatch: this.dispatch,\n            state: nav,\n            addListener: (eventName, handler) => {\n              if (eventName !== 'action') {\n                return { remove: () => {} };\n              }\n              this._actionEventSubscribers.add(handler);\n              return {\n                remove: () => {\n                  this._actionEventSubscribers.delete(handler);\n                },\n              };\n            },\n          };\n        }\n        navigation = this._navigation;\n      }\n      invariant(navigation, 'failed to get navigation');\n      return <Component {...this.props} navigation={navigation} />;\n    }\n  }\n\n  return polyfill(NavigationContainer);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAQA;AACA;AACA;AAVA;AACA;AAaA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AA6EA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvFA;AAAA;AA2MA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAFA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AA5MA;AAAA;AAAA;AAAA;AACA;AADA;AAgOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAJA;AADA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5PA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AADA;AAvBA;AA6BA;AACA;AA5CA;AAAA;AAAA;AA8CA;AAGA;AAjDA;AAAA;AAAA;AAoDA;AACA;AArDA;AAAA;AAAA;AAwDA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AACA;AAQA;AACA;AA1EA;AAAA;AAAA;AA6EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAzFA;AAAA;AAAA;AAuGA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhIA;AAAA;AAAA;AAmIA;AACA;AACA;AACA;AACA;AAvIA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AA0IA;AACA;AA3IA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AACA;AA8IA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AA3JA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AADA;AA4JA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AA5KA;AAAA;AACA;AADA;AA6KA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAIA;AACA;AACA;AA/LA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAkMA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAJA;AADA;AAQA;AACA;AA7MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAgNA;AACA;AACA;AAGA;AACA;AACA;AAvNA;AAAA;AAAA;AAkOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5OA;AAAA;AAAA;AA8QA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAbA;AAeA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AA1SA;AACA;AADA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AA0SA;AACA;;;;A","sourceRoot":""}