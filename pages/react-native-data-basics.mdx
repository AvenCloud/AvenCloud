

Create hook

Simple fetch hook

```tsx
export default function useLocations() {
  const [locations, setLocations] = useState(null);
  useEffect(() => {
    (async () => {
      const res = await fetch("https://www.purpleair.com/json", {});
      const data = await res.json();
      setLocations({ statusCode: res.status, data });
    })().catch((e) => {
      console.error(e);
    });
  }, []);
  return locations;
}

```

Simple cache hook:

https://react-native-community.github.io/async-storage/docs/usage/


```tsx
import { useEffect, useState } from "react";
import AsyncStorage from "@react-native-community/async-storage";

const cacheKey = "VioletLocations";

export default function useLocations() {
  const [locations, setLocations] = useState(null);
  useEffect(() => {
    (async () => {
      const cached = await AsyncStorage.getItem(cacheKey);
      let needsFetch = true;
      if (cached) {
        const { data, time } = JSON.parse(cached);
        console.log("cached", time, Object.keys(data));
        setLocations(data);
        needsFetch = time < Date.now() - 1000 * 60 * 60; // 1h cache
      }
      if (needsFetch) {
        const res = await fetch("https://www.purpleair.com/json", {});
        const data = await res.json();
        if (res.status === 200) {
          await AsyncStorage.setItem(
            cacheKey,
            JSON.stringify({ data, time: Date.now() })
          );
          setLocations(data);
        } else {
          console.error("Error during fetch!");
          console.error(data);
        }
      }
    })().catch((e) => {
      console.error(e);
    });
  }, []);
  return locations;
}
```

Too much data to display. FlatList helps render long lists in React Native.

```tsx
import React from "react";
import { StyleSheet, Text, View, SafeAreaView, FlatList } from "react-native";
import useLocations from "./useLocations";

function LocationCell({ name, color }: { name: string; color?: string }) {
  return (
    <View style={[styles.location, { backgroundColor: color }]}>
      <Text style={styles.locationName}>{name}</Text>
    </View>
  );
}

export default function App() {
  const locations = useLocations();
  if (!locations) {
    return <Text>Hang tight...</Text>;
  }
  function renderLocation({ item }: { item: { ID: string; Label: string } }) {
    return <LocationCell name={item.Label} color="purple" />;
  }
  return (
    <SafeAreaView style={styles.container}>
      <FlatList
        data={locations.results}
        renderItem={renderLocation}
        keyExtractor={(item) => item.ID}
        style={styles.container}
      />
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  location: {
    padding: 20,
  },
  locationName: {
    color: "white",
    fontSize: 32,
  },
  container: {
    flex: 1,
    backgroundColor: "#fff",
  },
});
```

Global cache with expiry:

The above solution works great if we only have one component which needs data. If we use it in multiple places, we will load the data from AsyncStorage multiple times.

To solve this problem, we will create a very simple store that our app will use to share data across components.

```tsx
import { useEffect, useMemo, useState } from "react";
import AsyncStorage from "@react-native-community/async-storage";

const cacheKey = "VioletLocations2";

interface LocationsData {
  results: Array<{
    ID: number;
    Label: string;
    PM2_5Value: string;
    Lat: number;
    Lon: number;
    humidity: number;
    temp_f: string;
    LastSeen: number;
    pressure: string;
    DEVICE_LOCATIONTYPE: "outside" | "inside";
  }>;
}

const cacheTimeMinutes = 60;

function createLocationsStore() {
  let data: LocationsData | undefined = undefined;
  let lastUpdate: number | undefined = undefined;

  const subscribers = new Set<(v: LocationsData) => void>();

  function setData(newData: LocationsData) {
    data = newData;
    subscribers.forEach((sub) => {
      sub(newData);
    });
  }

  async function loadFromRemote() {
    const res = await fetch("https://www.purpleair.com/json", {});
    const data = await res.json();
    if (res.status === 200) {
      lastUpdate = Date.now();
      setData(data);
      await AsyncStorage.setItem(
        cacheKey,
        JSON.stringify({ data, time: lastUpdate })
      );
    } else {
      console.error("Error during fetch!");
      console.error(data);
    }
  }
  async function warmCache() {
    if (!lastUpdate) {
      const cached = await AsyncStorage.getItem(cacheKey);
      if (cached) {
        const cacheData = JSON.parse(cached);
        lastUpdate = cacheData.time;
        setData(cacheData.data);
      }
    }
    if (!lastUpdate || lastUpdate < Date.now() - 1000 * 60 * cacheTimeMinutes) {
      await loadFromRemote();
    }
  }
  function warmCacheCaught(): Promise<void> {
    return warmCache().catch((e) => {
      console.error("Could not load data", e);
    });
  }
  let warmupInterval: number | null = null;

  function watch(subscriber: (v: LocationsData) => void) {
    warmCacheCaught().then(() => {
      if (!warmupInterval) {
        warmupInterval = setInterval(warmCacheCaught, 20_000);
      }
    });
    if (data !== undefined) {
      subscriber(data);
    }
    subscribers.add(subscriber);
    return () => {
      subscribers.delete(subscriber);
      if (!subscribers.size) {
        clearInterval(warmupInterval);
        warmupInterval = null;
      }
    };
  }

  function get(): LocationsData | undefined {
    return data;
  }
  return {
    watch,
    get,
  };
}

const store = createLocationsStore();

export default function useLocations() {
  const [data, setData] = useState<LocationsData | undefined>(store.get());
  useEffect(() => {
    return store.watch(setData);
  }, []);
  return data;
}
```

Also we will implement a hook that allows us to provide a query function over the store:

```tsx
export function useLocationData<Output>(
  mapper: (v: LocationsData) => Output,
  deps: React.DependencyList
) {
  const currentValue = store.get();
  const initialData =
    currentValue === undefined ? undefined : mapper(currentValue);
  const [data, setData] = useState<Output | undefined>(initialData);
  const storeHandler = useMemo(
    () => (v: LocationsData) => {
      setData(mapper(v));
    },
    deps
  );
  useEffect(() => {
    return store.watch(storeHandler);
  }, [storeHandler]);
  return data;
}
```